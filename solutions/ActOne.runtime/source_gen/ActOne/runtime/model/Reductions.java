package ActOne.runtime.model;

/*Generated by MPS */

import java.util.Map;
import java.util.HashMap;
import java.util.Queue;
import java.util.LinkedList;
import java.util.ArrayList;

public abstract class Reductions {

  public enum Traversal {
    BFS(),
    DFS()
  }


  /**
   * Reduces term by one iteration.
   * Algorithm: Iterative, Breadth-First Order.
   * 
   * @return next iteration of the term if reducable, the original term otherwise.
   */
  private static ITerm singleReductionBFS(boolean debug, ITerm root) {
    Map<ITerm, ITerm> parent_child = new HashMap<ITerm, ITerm>();
    Queue<ITerm> queue = new LinkedList<ITerm>();

    ITerm copy = root.clone();
    queue.add(copy);
    if (debug) {
      System.out.println("Root: " + queue.peek());
    }

    while (!(queue.isEmpty())) {
      ITerm current = queue.poll();
      ITerm previous = current;
      current = previous.reduceIteration();

      if (current == previous) {
        // If current node is not reducable 
        if (debug) {
          System.out.println("clean = " + current);
        }
        if (previous.terms != null) {
          for (ITerm child : previous.terms) {
            parent_child.put(child, previous);
            queue.add(child);
          }
        }
      } else {
        // If current node is reducable 
        if (debug) {
          System.out.println("dirty = " + previous + "\t->\t" + current + "\n");
        }

        // Check if current node is a root node 
        if (!(parent_child.containsKey(previous))) {
          return current;
        } else {
          ITerm parent = parent_child.get(previous);
          parent.terms.set(parent.terms.indexOf(previous), current);
          return copy;
        }

      }
    }

    // No reduction is found 
    return root;
  }


  /**
   * Reduces term by one iteration.
   * Algorithm: Recursive, Depth-First Post-Order.
   * 
   * @return next iteration of the term if reducable, the original term otherwise.
   */
  private static ITerm singleReductionDFS(boolean debug, ITerm root) {

    if (root.kind == ITerm.Kind.OPERATION) {
      for (int i = 0; i < root.terms.size(); i++) {
        ITerm child = root.terms.get(i);
        ITerm discoveredChild = singleReductionDFS(debug, child);
        if (!(child.equals(discoveredChild))) {
          ITerm copy = root.clone();
          copy.terms.set(i, discoveredChild);
          return copy;
        }
      }
    }

    ITerm result = root.reduceIteration();

    if (debug) {
      if (!(root.equals(result))) {
        System.out.println("dirty = " + root + "\t->\t" + result + "\n");
      } else {
        System.out.println("clean = " + result);
      }
    }
    return result;

  }


  /**
   * Bind Let-Declarations in the given term with corresponding value.
   */
  private static ITerm initBindTerm(boolean debug, ITerm term) {
    ITerm current = term;
    ITerm previous;
    do {
      if (debug) {
        System.out.println("Bind: " + current);
      }
      previous = current;
      current = bindTermIteration(previous);
    } while (current != previous);

    System.out.println();
    return current;
  }

  private static ITerm bindTermIteration(ITerm term) {
    switch (term.kind) {
      case INT:
        return term;
      case STRING:
        return term;
      case LET:
        ITerm value = ITerm.letAssignments.get(term);
        return value;
      case OPERATION:
        {
          ITerm copy = term.clone();
          ArrayList<ITerm> terms = copy.terms;
          for (int i = 0; i < terms.size(); i++) {
            ITerm previous = terms.get(i);
            ITerm current = bindTermIteration(previous);
            if (current != previous) {
              terms.set(i, current);
              return copy;
            }
          }
        }
        return term;
      default:
        throw new IllegalStateException("no_kind_error");
    }
  }

  /**
   * Stepwise Reduction
   */
  public static ITerm initReduction(Traversal traversal, boolean debug, int iterations, ITerm term) {

    System.out.println("\n\t[ init " + traversal.name() + " reduction ITERATIVE ]");

    ITerm original = initBindTerm(debug, term);
    ITerm root = original.clone();

    long startTime = System.nanoTime();

    while (iterations > 0) {

      if (debug) {
        System.out.println(">>>ITERATIONS LEFT = " + iterations);
      }

      ITerm previous = root;

      switch (traversal) {
        case BFS:
          root = singleReductionBFS(debug, root);
          break;
        case DFS:
          if (debug) {
            System.out.println("Root: " + root);
          }
          root = singleReductionDFS(debug, root);
          break;
        default:
          throw new IllegalStateException("no_traversal_error");
      }

      if (root == previous) {
        if (debug) {
          System.out.println("\n\t%%% Prematurely Break %%%");
        }
        break;
      }
      --iterations;
    }

    long endTime = System.nanoTime();

    if (root == term) {
      System.out.println("\n\t### NO REDUCTION FOUND:\t" + root);
    } else {
      System.out.print("\n\t### INPUT: \t" + original);
      System.out.println("\n\t### RESULT:\t" + root);
    }
    System.out.println("\t### Time elapsed:\t" + ((endTime - startTime) / 1000000.0 + " ms\n"));
    return root;
  }

  /**
   * Exhaustive Reduction
   */
  public static ITerm initReduction(Traversal traversal, boolean debug, ITerm term) {

    System.out.println("\n\t[ init " + traversal.name() + " reduction EXHAUSTIVE ]");

    ITerm original = initBindTerm(debug, term);
    ITerm root = original.clone();
    ITerm previous;

    long startTime = System.nanoTime();

    do {
      previous = root;

      switch (traversal) {
        case BFS:
          root = singleReductionBFS(debug, root);
          break;
        case DFS:
          if (debug) {
            System.out.println("Root: " + root);
          }
          root = singleReductionDFS(debug, root);
          break;
      }
    } while (root != previous);


    long endTime = System.nanoTime();

    if (root == term) {
      System.out.println("\n\t### NO REDUCTION FOUND:\t" + root);
    } else {
      System.out.print("\n\t### INPUT: \t" + original);
      System.out.println("\n\t### RESULT:\t" + root);
    }
    System.out.println("\t### Time elapsed:\t" + ((endTime - startTime) / 1000000.0 + " ms\n"));
    return root;
  }

}
