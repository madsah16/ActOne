package ActOne.runtime.model;

/*Generated by MPS */

import java.util.HashMap;
import java.util.LinkedList;
import java.util.ArrayList;

public class Axiom {

  private final ITerm left;
  private final ITerm right;

  public Axiom(ITerm left, ITerm right) {
    this.left = left;
    this.right = right;
  }

  @Override
  public String toString() {
    return left + " = " + right;
  }

  public ITerm reduce(ITerm root) {

    HashMap<ITerm, ITerm> tempAssignments = new HashMap<ITerm, ITerm>();

    LinkedList<ITerm> openSet = new LinkedList<ITerm>();
    openSet.add(left);
    openSet.add(root.clone());

    while (!(openSet.isEmpty())) {

      ITerm axiomNode = openSet.pollFirst();
      ITerm targetNode = openSet.pollFirst();

      // Error Check 
      if (axiomNode == null || targetNode == null) {
        return root;
      }

      // Sort equivalence check 
      if (axiomNode.getClass() != targetNode.getClass()) {
        return root;
      }

      // Prematurely match 
      if (axiomNode == targetNode) {
        continue;
      }

      if (axiomNode.kind == ITerm.Kind.VARIABLE) {
        if (tempAssignments.containsKey(axiomNode)) {
          if (!(tempAssignments.get(axiomNode).equals(targetNode))) {
            return root;
          }
        } else {
          tempAssignments.put(axiomNode, targetNode);
        }
      } else if (axiomNode.kind == ITerm.Kind.OPERATION && targetNode.kind == ITerm.Kind.OPERATION) {
        if (axiomNode.operator != targetNode.operator) {
          return root;
        }
        if (axiomNode.terms.size() != targetNode.terms.size()) {
          return root;
        }
        for (int i = 0; i < axiomNode.terms.size(); i++) {
          openSet.add(axiomNode.terms.get(i));
          openSet.add(targetNode.terms.get(i));
        }
      } else {
        return root;
      }

    }

    return applyAxiom(right, tempAssignments);
  }


  /**
   * Clones the right-term of current axiom with all variables bound.
   * 
   * @param rightTerm axiom's right-term
   * @param assignments mappings of variable -> term
   * @return a copy of right-term with all variables bound. 
   */
  public ITerm applyAxiom(ITerm rightTerm, HashMap<ITerm, ITerm> assignments) {
    switch (rightTerm.kind) {
      case INT:
        return rightTerm.clone();
      case VARIABLE:
        return assignments.get(rightTerm);
      case OPERATION:
        {
          ITerm copy = rightTerm.clone();
          ArrayList<ITerm> axiomChildren = new ArrayList<ITerm>();
          for (ITerm t : rightTerm.terms) {
            axiomChildren.add(applyAxiom(t, assignments));
          }
          copy.terms = axiomChildren;
          return copy;
        }
      default:
        throw new IllegalStateException("no_kind_error");
    }
  }

}
