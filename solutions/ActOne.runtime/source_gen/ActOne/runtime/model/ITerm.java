package ActOne.runtime.model;

/*Generated by MPS */

import java.util.HashMap;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Objects;

public class ITerm implements Cloneable {

  public enum Kind {
    INT(),
    STRING(),
    VARIABLE(),
    OPERATION(),
    LET()
  }

  /*package*/ static HashMap<ITerm, ITerm> letAssignments = new HashMap<ITerm, ITerm>();

  public static ITerm let(String name, ITerm term) {

    ITerm key = null;
    try {
      key = term.getClass().getConstructor(Kind.class, String.class).newInstance(Kind.LET, name);
      letAssignments.put(key, term);
    } catch (Exception e) {
      System.out.println("ERROR: Constructor_NOT_FOUND:\t" + e);
    }
    System.out.println("Let: " + key + " = " + term);
    return key;

  }

  private static ArrayList<Axiom> axioms = new ArrayList<Axiom>();

  public static int getAxiomsSize() {
    return axioms.size();
  }

  public static void axiom(ITerm left, ITerm right) {
    axioms.add(new Axiom(left, right));
  }

  public final int intVal;
  public final String stringVal;

  public final Kind kind;
  public final String name;

  public final Operator operator;
  public ArrayList<ITerm> terms;


  /**
   * Constructor for string-term
   */
  public ITerm(String val) {
    this.kind = Kind.STRING;
    this.name = null;
    this.terms = new ArrayList<ITerm>();
    this.intVal = 0;
    this.stringVal = val;
    this.operator = null;
  }


  /**
   * Constructor for int-term
   */
  public ITerm(int val) {
    this.kind = Kind.INT;
    this.name = null;
    this.terms = new ArrayList<ITerm>();
    this.intVal = val;
    this.stringVal = null;
    this.operator = null;
  }

  public ITerm(Kind kind, String name) {
    this.kind = kind;
    this.name = name;
    this.intVal = 0;
    this.stringVal = null;
    this.operator = null;
    this.terms = null;
  }

  public ITerm(Operator operator, ITerm... terms) {
    this.kind = Kind.OPERATION;
    this.name = null;
    this.intVal = 0;
    this.stringVal = null;
    this.operator = operator;
    this.terms = new ArrayList<ITerm>();
    Collections.addAll(this.terms, terms);
  }

  @Override
  public String toString() {
    switch (kind) {
      case INT:
        return intVal + "";
      case STRING:
        return '"' + stringVal + '"';
      case LET:
        return name;
      case VARIABLE:
        return name;
      case OPERATION:
        {
          String str = this.operator + "(";
          if (0 < terms.size()) {
            for (ITerm t : terms) {
              str += t + ", ";
            }
            str = str.substring(0, str.length() - 2);
          }
          return str + ")";
        }
      default:
        return "error_no_kind";
    }
  }

  @Override
  public boolean equals(Object obj) {

    if (obj == null) {
      return false;
    }
    if (!((obj instanceof ITerm))) {
      return false;
    }
    ITerm target = (ITerm) obj;

    switch (kind) {
      case INT:
        if (target.kind == Kind.INT) {
          return this.intVal == target.intVal;
        }
        return false;
      case STRING:
        if (target.kind == Kind.STRING) {
          return this.stringVal.equals(target.stringVal);
        }
        return false;
      case VARIABLE:
        switch (target.kind) {
          case VARIABLE:
            return this == target;
          case OPERATION:
            return this.getClass() == target.getClass();
          default:
            throw new IllegalStateException("Unexpected value" + target.kind);
        }
      case OPERATION:
        switch (target.kind) {
          case STRING:
            return false;
          case INT:
            return false;
          case VARIABLE:
            return target.equals(this);
          case OPERATION:
            if (this.operator != target.operator) {
              return false;
            }
            if (this.terms.size() != target.terms.size()) {
              return false;
            }

            for (int i = 0; i < terms.size(); i++) {
              if (!(this.terms.get(i).equals(target.terms.get(i)))) {
                return false;
              }
            }
            return true;
          default:
            throw new IllegalStateException("Unexpected value" + target.kind);
        }
      default:
        throw new IllegalStateException("Unexpected value" + target.kind);
    }
  }

  @Override
  public ITerm clone() {
    if (kind == Kind.OPERATION) {
      try {
        ITerm result = (ITerm) super.clone();
        result.terms = new ArrayList<ITerm>();
        for (ITerm t : terms) {
          result.terms.add(t.clone());
        }
        return result;
      } catch (CloneNotSupportedException e) {
        throw new AssertionError();
      }
    }
    return this;
  }

  @Override
  public int hashCode() {
    return Objects.hash(this.kind, this.name, this.operator, this.terms);
  }


  /**
   * Reduces the current term with non-predefined-axioms.
   */
  public ITerm useNonpredefinedAxioms() {
    for (Axiom axiom : axioms) {
      final ITerm current = axiom.reduce(this);
      if (!(current.equals(this))) {
        return current;
      }
    }

    return this;
  }


  /**
   * Reduces the current term by one iteration if possible.
   * This method is overriden by predefined sorts, as they require unique reduction scheme.
   * 
   * @return the reduced term if reducable, the original term otherwise.
   */
  public ITerm reduceIteration() {
    return useNonpredefinedAxioms();
  }

}
