package ActOne.runtime.predefined;

/*Generated by MPS */

import ActOne.runtime.model.ITerm;
import ActOne.runtime.model.Operator;

public abstract class BOOLEAN {

  public static class Bool extends ITerm {

    public Bool(Operator operator, ITerm... terms) {
      super(operator, terms);
    }
    public Bool(ITerm.Kind kind, String name) {
      super(kind, name);
    }

    private boolean isGroundTerm(ITerm term) {
      return (term.operator == oper_True || term.operator == oper_False ? true : false);
    }

    private boolean b(ITerm term) {
      return (term.operator == oper_True ? true : false);
    }

    private Bool t(boolean bool) {
      return (bool ? True() : False());
    }

    @Override
    public ITerm reduceIteration() {

      // Only perform reduce if term is an operator 
      if (kind == ITerm.Kind.LET || kind == ITerm.Kind.VARIABLE) {
        return this;
      }

      // Copy of the original root 
      ITerm root = this.clone();

      switch (BOOLEAN.oper_code(root.operator)) {
        case TRUE:
          break;
        case FALSE:
          break;
        case NOT:
          ITerm child = root.terms.get(0);
          if (isGroundTerm(child)) {
            root = t(!(b(child)));
          }
          break;
        case AND:
          {
            ITerm leftChild = root.terms.get(0);
            ITerm rightChild = root.terms.get(1);
            if (isGroundTerm(leftChild) && isGroundTerm(rightChild)) {
              root = t(b(leftChild) && b(rightChild));
            }
          }
          break;
        case OR:
          {
            ITerm leftChild = root.terms.get(0);
            ITerm rightChild = root.terms.get(1);
            if (isGroundTerm(leftChild) && isGroundTerm(rightChild)) {
              root = t(b(leftChild) || b(rightChild));
            }
          }
          break;
        case IF:
          {
            ITerm firstBorn = root.terms.get(0);
            ITerm secondBorn = root.terms.get(1);
            ITerm thirdBorn = root.terms.get(2);
            if (isGroundTerm(firstBorn)) {
              root = (b(firstBorn) ? secondBorn : thirdBorn);
            }
          }
          break;
        case EQUAL:
          {
            ITerm leftChild = root.terms.get(0);
            ITerm rightChild = root.terms.get(1);

            if (leftChild.equals(rightChild)) {
              root = True();
            } else {
              // Check if both term is reducable 
              boolean leftIsReducable = leftChild != leftChild.reduceIteration();
              boolean rightIsReducable = rightChild != rightChild.reduceIteration();

              // If both term is non-reducable, equal-operation can safely reduce into False() 
              if (!(leftIsReducable) && !(rightIsReducable)) {
                root = False();
              }
            }
            // Else, it is not currently solvable 
          }
          break;
        case GREATER_THAN:
          {
            ITerm leftChild = root.terms.get(0);
            ITerm rightChild = root.terms.get(1);

            if (leftChild.kind == ITerm.Kind.INT && rightChild.kind == ITerm.Kind.INT) {
              root = (leftChild.intVal < rightChild.intVal ? BOOLEAN.True() : BOOLEAN.False());
            }
          }
          break;
        case EQUAL_OR_GREATER_THAN:
          {
            ITerm leftChild = root.terms.get(0);
            ITerm rightChild = root.terms.get(1);
            if (leftChild.kind == ITerm.Kind.INT && rightChild.kind == ITerm.Kind.INT) {
              root = (leftChild.intVal <= rightChild.intVal ? BOOLEAN.True() : BOOLEAN.False());
            }
          }
          break;
        default:
          break;
      }

      // If not reduced, try non-predefined axioms 
      if (this.equals(root)) {
        return this.useNonpredefinedAxioms();
      }
      return root;

    }
  }

  private enum OPER {
    TRUE(),
    FALSE(),
    NOT(),
    AND(),
    OR(),
    EQUAL(),
    IF(),
    GREATER_THAN(),
    EQUAL_OR_GREATER_THAN(),
    OTHER()
  }

  public static OPER oper_code(Operator input) {
    if (input == oper_True) {
      return OPER.TRUE;
    }
    if (input == oper_False) {
      return OPER.FALSE;
    }
    if (input == oper_Not) {
      return OPER.NOT;
    }
    if (input == oper_and) {
      return OPER.AND;
    }
    if (input == oper_or) {
      return OPER.OR;
    }
    if (input == oper_equal) {
      return OPER.EQUAL;
    }
    if (input == oper_if) {
      return OPER.IF;
    }
    if (input == INTEGER.oper_GR) {
      return OPER.GREATER_THAN;
    }
    if (input == INTEGER.oper_EQ_GR) {
      return OPER.EQUAL_OR_GREATER_THAN;
    }
    return OPER.OTHER;
  }




  private static Operator oper_True = new Operator(true, "true");
  private static Operator oper_False = new Operator(true, "false");
  private static Operator oper_Not = new Operator(false, "not");
  private static Operator oper_and = new Operator(false, "and");
  private static Operator oper_or = new Operator(false, "or");
  private static Operator oper_equal = new Operator(false, "equal");
  private static Operator oper_if = new Operator(false, "if");

  public static Bool True() {
    return new Bool(oper_True);
  }

  public static Bool False() {
    return new Bool(oper_False);
  }

  public static Bool Not(Bool term) {
    return new Bool(oper_Not, term);
  }

  public static Bool And(Bool left, Bool right) {
    return new Bool(oper_and, left, right);
  }

  public static Bool Or(Bool left, Bool right) {
    return new Bool(oper_or, left, right);
  }

  public static Bool Equal(ITerm left, ITerm right) {
    return new Bool(oper_equal, left, right);
  }

  public static Bool If_Then_Else(Bool _case, ITerm _then, ITerm _else) {
    return new Bool(oper_if, _case, _then, _else);
  }

  public static void initAxioms() {
    System.out.println("Inbuilt-Boolean loaded");
  }

}
