package ActOne.runtime.predefined;

/*Generated by MPS */

import ActOne.runtime.model.ITerm;
import ActOne.runtime.model.Operator;

public abstract class INTEGER {
  public static class Int extends ITerm {


    /**
     * Add intVal
     */
    public Int(int val) {
      super(val);
    }
    public Int(ITerm.Kind kind, String name) {
      super(kind, name);
    }
    public Int(Operator operator, ITerm... terms) {
      super(operator, terms);
    }
    @Override
    public ITerm reduceIteration() {

      // Only perform reduce if term is an operator 
      if (kind == ITerm.Kind.LET || kind == ITerm.Kind.VARIABLE) {
        return this;
      }

      // Copy of the original root 
      ITerm root = this.clone();

      switch (root.terms.size()) {
        case 1:
          // Due to output type, STRING's Length() must be reduced here 
          if (root.operator == STRING.oper_Length) {
            ITerm child = root.terms.get(0);
            if (child.kind == ITerm.Kind.STRING) {
              root = natValueTerm(child.stringVal.length());
            }
          }
          break;
        case 2:

          // Binary Operations 
          ITerm leftChild = root.terms.get(0);
          ITerm rightChild = root.terms.get(1);

          // Check if children are constants/ground-terms 
          if (leftChild.kind != ITerm.Kind.INT || rightChild.kind != ITerm.Kind.INT) {
            break;
          }

          if (root.operator == oper_Add) {
            root = natValueTerm(leftChild.intVal + rightChild.intVal);
          } else if (root.operator == oper_Sub) {
            root = natValueTerm(leftChild.intVal - rightChild.intVal);
          } else if (root.operator == oper_Mul) {
            root = natValueTerm(leftChild.intVal * rightChild.intVal);
          } else if (root.operator == oper_Div) {
            root = natValueTerm(leftChild.intVal / rightChild.intVal);
          } else if (root.operator == oper_Pow) {
            root = natValueTerm((int) Math.pow(leftChild.intVal, rightChild.intVal));
          } else if (root.operator == oper_Mod) {
            root = natValueTerm(leftChild.intVal % rightChild.intVal);
          }

          // EQUAL OR GREATER + GREATER is handled in BOOLEAN 

          break;
        default:
          break;
      }

      // If not reduced, try non-predefined axioms 
      if (this.equals(root)) {
        return this.useNonpredefinedAxioms();
      }
      return root;
    }

  }


  /**
   * Create a intTerm
   */
  public static Int natValueTerm(int val) {
    return new Int(val);
  }

  private static Operator oper_Add = new Operator(false, "ADD");
  private static Operator oper_Sub = new Operator(false, "SUB");
  private static Operator oper_Mul = new Operator(false, "MUL");
  private static Operator oper_Div = new Operator(false, "DIV");
  private static Operator oper_Pow = new Operator(false, "POW");
  private static Operator oper_Mod = new Operator(false, "MOD");
  public static Operator oper_GR = new Operator(false, "GR");
  public static Operator oper_EQ_GR = new Operator(false, "EQ_GR");

  public static Int ADD(Int left, Int right) {
    return new Int(oper_Add, left, right);
  }

  public static Int SUB(Int left, Int right) {
    return new Int(oper_Sub, left, right);
  }

  public static Int MUL(Int left, Int right) {
    return new Int(oper_Mul, left, right);
  }

  public static Int DIV(Int left, Int right) {
    return new Int(oper_Div, left, right);
  }

  public static Int POW(Int left, Int right) {
    return new Int(oper_Pow, left, right);
  }

  public static Int MOD(Int left, Int right) {
    return new Int(oper_Mod, left, right);
  }

  public static BOOLEAN.Bool GR(Int left, Int right) {
    return new BOOLEAN.Bool(oper_GR, left, right);
  }

  public static BOOLEAN.Bool EQ_GR(Int left, Int right) {
    return new BOOLEAN.Bool(oper_EQ_GR, left, right);
  }




  public static void initAxioms() {
    System.out.println("Inbuilt-Integer loaded");
  }




}
